<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>–¢–µ—Ç—Ä–∏—Å | –° –î–Ω–µ–º –†–æ–∂–¥–µ–Ω–∏—è!</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      touch-action: none;
    }
    body {
      font-family: 'Arial', sans-serif;
      background: #1a1a1a;
      color: white;
      overflow: hidden;
    }
    .menu-container {
      position: fixed;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #2c3e50, #3498db);
      z-index: 2;
    }
    .birthday-card {
      background: rgba(255, 255, 255, 0.95);
      padding: 2rem;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      max-width: 90%;
    }
    .birthday-card h1 {
      color: #e74c3c;
      margin-bottom: 1rem;
      font-size: 2.5em;
    }
    .birthday-card p {
      color: #2c3e50;
      margin-bottom: 1.5rem;
      line-height: 1.6;
    }
    .start-button {
      background: #27ae60;
      color: white;
      border: none;
      padding: 1rem 2rem;
      font-size: 1.2em;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.2s, background 0.2s;
    }
    .start-button:active {
      transform: scale(0.95);
      background: #219a52;
    }
    .game-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #1a1a1a;
      z-index: 3;
    }
    .game-header {
      margin-bottom: 1rem;
      text-align: center;
    }
    #tetris {
      border: 2px solid #34495e;
      background: #2c3e50;
    }
    .mobile-controls {
      margin-top: 1.5rem;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      width: 100%;
      max-width: 400px;
      padding: 0 10px;
    }
    .mobile-controls button {
      background: #34495e;
      border: none;
      color: white;
      padding: 15px;
      border-radius: 10px;
      font-size: 1.5em;
      touch-action: none;
    }
    .mobile-controls button:active {
      background: #2c3e50;
    }
    #rotate-btn {
      grid-column: span 3;
    }
    @media (max-width: 600px) {
      #tetris {
        width: 80vw;
        height: 80vw;
      }
    }
  </style>
  <!-- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –ø–∞–¥–∞—é—â–∏—Ö –ª–µ–ø–µ—Å—Ç–∫–æ–≤ —Å —Ñ–∏–∑–∏–∫–æ–π -->
  <style>
    /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –ø–∞–¥–∞—é—â–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ —Ä–∞—Å–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ */
    .falling-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    /* –°—Ç–∏–ª–∏ –¥–ª—è –ª–µ–ø–µ—Å—Ç–∫–æ–≤ ‚Äì –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è */
    .petal {
      position: absolute;
      width: 30px;
      height: 30px;
      background-size: contain;
      background-repeat: no-repeat;
    }
    .petal1 { background-image: url('images/petal1.png'); }
    .petal2 { background-image: url('images/petal2.png'); }
  </style>
</head>
<body>
  <div class="menu-container">
    <div class="birthday-card">
      <h1>üéâ –° –î–Ω–µ–º –†–æ–∂–¥–µ–Ω–∏—è! üéÇ</h1>
      <p>–ñ–µ–ª–∞–µ–º —Ç–µ–±–µ —è—Ä–∫–∏—Ö –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏–π, —É—Å–ø–µ—Ö–æ–≤ –≤–æ –≤—Å–µ—Ö –Ω–∞—á–∏–Ω–∞–Ω–∏—è—Ö –∏ –æ—Ç–ª–∏—á–Ω–æ–≥–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è! üöÄ</p>
      <button class="start-button" onclick="startGame()">–∏–≥—Ä–∞–π —ã –º–æ—é –∏–≥—Ä—ÉüéÆ</button>
    </div>
  </div>
  <div class="game-container" id="gameContainer">
    <div class="game-header">
      <h2>–û—á–∫–∏: <span id="score">0</span></h2>
    </div>
    <canvas id="tetris"></canvas>
    <div class="mobile-controls">
      <button id="left">‚Üê</button>
      <button id="down">‚Üì</button>
      <button id="right">‚Üí</button>
      <button id="rotate-btn">‚Üª –ü–æ–≤–æ—Ä–æ—Ç</button>
    </div>
  </div>
  
  <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –ø–∞–¥–∞—é—â–∏—Ö –ª–µ–ø–µ—Å—Ç–∫–æ–≤ -->
  <div class="falling-container" id="fallingContainer"></div>
  
  <script>
    // –ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ Tetris (–æ—Å—Ç–∞–≤–ª–µ–Ω –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    
    const BLOCK_SIZE = 30;
    const COLS = 10;
    const ROWS = 20;
    let score = 0;
    let rewardTriggered = false;
    
    const SHAPES = [
      [[1, 1, 1, 1]],
      [[1, 1], [1, 1]],
      [[1, 1, 1], [0, 1, 0]],
      [[1, 1, 1], [1, 0, 0]],
      [[1, 1, 1], [0, 0, 1]],
      [[1, 1, 0], [0, 1, 1]],
      [[0, 1, 1], [1, 1, 0]]
    ];
    
    const COLORS = ['#e74c3c', '#2ecc71', '#9b59b6', '#f1c40f', '#3498db'];
    const arena = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    
    let currentPiece = null;
    let gameLoop = null;
    let gameSpeed = 1000;
    
    function initCanvas() {
      canvas.width = COLS * BLOCK_SIZE;
      canvas.height = ROWS * BLOCK_SIZE;
      context.scale(BLOCK_SIZE, BLOCK_SIZE);
    }
    
    function createPiece() {
      const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      return {
        shape,
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        x: Math.floor(COLS / 2 - shape[0].length / 2),
        y: 0
      };
    }
    
    function collide() {
      return currentPiece.shape.some((row, dy) =>
        row.some((value, dx) =>
          value &&
          (arena[currentPiece.y + dy]?.[currentPiece.x + dx] ||
           currentPiece.x + dx < 0 ||
           currentPiece.x + dx >= COLS ||
           currentPiece.y + dy >= ROWS)
        )
      );
    }
    
    function merge() {
      currentPiece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            arena[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
          }
        });
      });
    }
    
    function clearLines() {
      let linesCleared = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (arena[y].every(cell => cell)) {
          arena.splice(y, 1);
          arena.unshift(Array(COLS).fill(0));
          linesCleared++;
          y++;
        }
      }
      if (linesCleared > 0) {
        score += linesCleared * 100;
        scoreElement.textContent = score;
        if (score >= 100 && !rewardTriggered) {
          rewardTriggered = true;
          setTimeout(() => {
            alert("üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø—Ä–∏–∑!");
            window.location.href = "https://youtube.com/shorts/naFvn4VteQk";
          }, 500);
        }
        gameSpeed = Math.max(300, 1000 - score * 2);
      }
    }
    
    function move(dx) {
      currentPiece.x += dx;
      if (collide()) {
        currentPiece.x -= dx;
        return false;
      }
      return true;
    }
    
    function rotate() {
      const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[i]).reverse()
      );
      const previousShape = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collide()) {
        currentPiece.shape = previousShape;
      }
    }
    
    function drop() {
      currentPiece.y++;
      if (collide()) {
        currentPiece.y--;
        merge();
        clearLines();
        currentPiece = createPiece();
        if (collide()) {
          alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –°—á–µ—Ç: ${score}`);
          resetGame();
        }
      }
    }
    
    function draw() {
      context.fillStyle = '#2c3e50';
      context.fillRect(0, 0, canvas.width, canvas.height);
      arena.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            context.fillStyle = value;
            context.fillRect(x, y, 1, 1);
          }
        });
      });
      if (currentPiece) {
        context.fillStyle = currentPiece.color;
        currentPiece.shape.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value) {
              context.fillRect(currentPiece.x + x, currentPiece.y + y, 1, 1);
            }
          });
        });
      }
    }
    
    function update() {
      drop();
      draw();
    }
    
    function resetGame() {
      arena.forEach(row => row.fill(0));
      score = 0;
      rewardTriggered = false;
      scoreElement.textContent = score;
      currentPiece = createPiece();
      gameSpeed = 1000;
      clearInterval(gameLoop);
      gameLoop = setInterval(update, gameSpeed);
    }
    
    document.addEventListener('keydown', e => {
      switch(e.key) {
        case 'ArrowLeft': move(-1); break;
        case 'ArrowRight': move(1); break;
        case 'ArrowDown': drop(); break;
        case 'ArrowUp': rotate(); break;
      }
      draw();
    });
    
    document.getElementById('left').addEventListener('touchstart', () => move(-1));
    document.getElementById('right').addEventListener('touchstart', () => move(1));
    document.getElementById('down').addEventListener('touchstart', drop);
    document.getElementById('rotate-btn').addEventListener('touchstart', rotate);
    
    function startGame() {
      document.querySelector('.menu-container').style.display = 'none';
      document.getElementById('gameContainer').style.display = 'flex';
      initCanvas();
      resetGame();
    }
    // –ö–æ–Ω–µ—Ü –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ Tetris
  </script>
  
  <!-- –°–∫—Ä–∏–ø—Ç –¥–ª—è –ø–∞–¥–∞—é—â–∏—Ö –ª–µ–ø–µ—Å—Ç–∫–æ–≤ —Å —Ñ–∏–∑–∏–∫–æ–π —Å –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–º —Å–ø–∞–≤–Ω–æ–º -->
  <script>
    const fallingContainer = document.getElementById('fallingContainer');
    
    class FallingObject {
      constructor() {
        this.element = document.createElement('div');
        // –í—Å–µ–≥–¥–∞ —Å–æ–∑–¥–∞—ë–º –ª–µ–ø–µ—Å—Ç–æ–∫, —Å–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º —Ç–∏–ø 'petal1' –∏–ª–∏ 'petal2'
        this.element.className = Math.random() < 0.5 ? 'petal petal1' : 'petal petal2';
        fallingContainer.appendChild(this.element);
        this.x = Math.random() * window.innerWidth;
        this.y = -50;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = Math.random() * 2 + 1;
        this.rotation = Math.random() * 360;
        this.rotationSpeed = (Math.random() - 0.5) * 5;
        this.updateStyle();
      }
      updateStyle() {
        this.element.style.left = this.x + 'px';
        this.element.style.top = this.y + 'px';
        this.element.style.transform = 'rotate(' + this.rotation + 'deg)';
      }
      update() {
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é –∏ —Å–ª—É—á–∞–π–Ω—ã–π –≤–µ—Ç–µ—Ä
        this.vy += 0.05;
        this.vx += (Math.random() - 0.5) * 0.1;
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.updateStyle();
      }
      isOffScreen() {
        return this.y > window.innerHeight + 50;
      }
    }
    
    let fallingObjects = [];
    
    function spawnFallingObject() {
      // –°–ø–∞–≤–Ω–∏–º 5 –ª–µ–ø–µ—Å—Ç–∫–æ–≤ –∑–∞ —Ä–∞–∑ –¥–ª—è –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
      for (let i = 0; i < 5; i++) {
        fallingObjects.push(new FallingObject());
      }
    }
    
    function updateFallingObjects() {
      for (let i = fallingObjects.length - 1; i >= 0; i--) {
        fallingObjects[i].update();
        if (fallingObjects[i].isOffScreen()) {
          fallingObjects[i].element.remove();
          fallingObjects.splice(i, 1);
        }
      }
      requestAnimationFrame(updateFallingObjects);
    }
    
    // –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π —Å–ø–∞–≤–Ω: –∫–∞–∂–¥—ã–µ 20 –º—Å
    setInterval(spawnFallingObject, 50);
    updateFallingObjects();
  </script>
</body>
</html>
